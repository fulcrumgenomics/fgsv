package com.fulcrumgenomics.sv.tools

import com.fulcrumgenomics.FgBioDef.FilePath
import com.fulcrumgenomics.sopt.{arg, clp}
import com.fulcrumgenomics.sv.BreakpointPileup
import com.fulcrumgenomics.sv.cmdline.{ClpGroups, SvTool}
import com.fulcrumgenomics.sv.tools.AggregateSvPileup.PileupGroup
import com.fulcrumgenomics.sv.tools.AggregatedBreakpointPileup.addId
import com.fulcrumgenomics.sv.tools.BreakpointCategory.BreakpointCategory
import com.fulcrumgenomics.util.{Io, Metric}

import scala.annotation.tailrec
import scala.collection.mutable


@clp(group=ClpGroups.All, description=
  """
    |Merges nearby pileups of reads supporting putative breakpoints.
    |
    |Takes as input the file of pileups produced by `SvPileup`. That file contains a list of breakpoints, each
    |consisting of a chromosome, position and strand for each side of the breakpoint, as well as quantified read support
    |for the breakpoint.
    |
    |This tool merges sets of breakpoints that have their left sides on the same chromosome, their right sides on the
    |same chromosome, the same left and right strands, and their left and right positions both within a length
    |threshold. The merging behavior is transitive. For example, two breakpoints that are farther apart than the length
    |threshold can be merged if there is a third breakpoint that is close to both.
    |
    |The output file is a tab-delimited table with one record per aggregated cluster of pileups. Aggregated
    |pileups are reported with the minimum and maximum (inclusive) coordinates of all pileups in the cluster, a
    |possible putative structural variant event type supported by the pileups, and the sum of read support from all
    |pileups in the cluster.
    |""")
class AggregateSvPileup
(@arg(flag='i', doc="The input text file of pileups generated by SvPileup") input: FilePath,
 @arg(flag='o', doc="The output file") output: FilePath,
 @arg(flag='d', doc="Distance threshold below which to cluster breakpoints") maxDist: Int = 100,
) extends SvTool {

  Io.assertReadable(input)
  Io.assertCanWriteFile(output)

  override def execute(): Unit = {
    // Read pileups from input file
    val pileups: Seq[BreakpointPileup] = Metric.read[BreakpointPileup](input)

    // Open output writer
    val writer = Metric.writer[AggregatedBreakpointPileup](output)

    // Group pileups by left and right contig and strand
    pileups.groupMap(BreakpointContigOrientation(_))(identity).foreach { case (_, group) =>

      // Within each contig+strand group, identify all immediate "neighbors" of each pileup (other pileups within the
      // distance threshold)
      val pileupToNeighbors: Map[BreakpointPileup, PileupGroup] = AggregateSvPileup.pileupToNeighbors(group, maxDist)

      // Within each contig+strand group, recursively build (transitive) clusters of neighboring pileups
      val pileupClusters: Seq[PileupGroup] = AggregateSvPileup.toClusters(pileupToNeighbors)

      // Aggregate each cluster
      val aggregatedPileups: Seq[AggregatedBreakpointPileup] = pileupClusters.map(AggregatedBreakpointPileup.apply)

      // Write to output file
      aggregatedPileups.foreach(writer.write)
    }

    writer.close()

  }

}


object AggregateSvPileup {

  /** Type alias for a collection of pileups */
  type PileupGroup = Seq[BreakpointPileup]

  /**
   * Maps each pileup to the set of other pileups within the distance threshold.
   *
   * Note: it is recommended to call this method on a group of pileups that share a common `BreakpointContigOrientation`
   * to reduce unnecessary run time.
   *
   * @param pileups Set of pileups to evaluate for pairwise neighbor relationships
   * @param maxDist Maximum distance (inclusive) for the left and right coordinates to be considered a neighbor
   * @return Map of pileup to the set of neighbors
   */
  private def pileupToNeighbors(pileups: PileupGroup, maxDist: Int): Map[BreakpointPileup, PileupGroup] = {
    val map: mutable.Map[BreakpointPileup, List[BreakpointPileup]] = mutable.Map.from(pileups.map((_, Nil)))
    for (pileup1 <- pileups; pileup2 <- pileups) {
      if (pileup1.total >= pileup2.total && isCluster(pileup1, pileup2, maxDist)) {
        map.put(pileup1, pileup2 :: map(pileup1))
        map.put(pileup2, pileup1 :: map(pileup2))
      }
    }
    map.toMap
  }

  /** Returns true if the two breakpoints can be clustered, i.e., they are not the same breakpoint (have different
   * IDs), they have the same left and right chromosomes and strand, and the distance between their left and right
   * coordinates is below the threshold (inclusive) */
  private def isCluster(bp1: BreakpointPileup, bp2: BreakpointPileup, maxDist: Int): Boolean = {
    bp1.id != bp2.id &&
      BreakpointContigOrientation(bp1) == BreakpointContigOrientation(bp2) &&
      Math.abs(bp1.left_pos - bp2.left_pos) <= maxDist &&
      Math.abs(bp1.right_pos - bp2.right_pos) <= maxDist
  }

  /**
   * Converts a set of pairwise neighbor relationships to a set of clusters, where each cluster consists of breakpoints
   * that can be joined into a connected path via pairwise neighbor relationships.
   * @param pileupToNeighbors Map of pileup to its set of neighbors
   * @param existingClusters An existing set of clusters to add to
   * @return The set of pileup clusters
   */
  @tailrec
  def toClusters(pileupToNeighbors: Map[BreakpointPileup, PileupGroup],
                 existingClusters: Seq[PileupGroup] = Seq()): Seq[PileupGroup] = {
    if (pileupToNeighbors.isEmpty) {
      existingClusters
    } else {
      val (pileupGroup, remaining) = extractClusterFor(pileupToNeighbors.keys.head, pileupToNeighbors)
      toClusters(remaining, existingClusters :+ pileupGroup)
    }
  }

  /**
   * Extracts the complete connected cluster containing the given pileup from the map of pileups to their neighbor sets,
   * and returns the cluster along with the reduced map of pileup to neighbor set such that no remaining pileups in the
   * map belong in a cluster with the returned cluster.
   *
   * Implementation note: the implementation is not tail-recursive, but in practice the recursion depth is small.
   *
   * @param pileup The pileup representative of the cluster that will be returned
   * @param pileupToNeighbors Map of pileup to its set of neighbors
   * @param existingCluster An existing cluster to add to
   * @return (1) The complete cluster for the given pileup; (2) Reduced version of `pileupToNeighbors` with all pileups
   *         in the returned cluster having been removed from both keys and values.
   */
  def extractClusterFor(pileup: BreakpointPileup, pileupToNeighbors: Map[BreakpointPileup, PileupGroup],
                        existingCluster: PileupGroup = Seq()): (PileupGroup, Map[BreakpointPileup, PileupGroup]) = {

    // Identify the immediate neighbors of the given pileup, and start a cluster containing them
    val neighbors: PileupGroup = pileupToNeighbors.getOrElse(pileup, Seq.empty)
    val currCluster: PileupGroup = neighbors :+ pileup

    // Remove the given pileup and its immediate neighbors from `pileupToNeighbors`
    val reducedRemainingGroups: Map[BreakpointPileup, PileupGroup] = pileupToNeighbors.removed(pileup)

    // Recursively build a cluster consisting of this pileup's immediate neighbors, their immediate neighbors,
    // and so on. With each iteration of the foldLeft operation, we are keeping track of a tuple consisting of
    // (1) a growing connected cluster, and (2) a shrinking map of remaining pileups to their neighbor sets.
    neighbors.foldLeft((currCluster, reducedRemainingGroups)) { case ((currCluster, remaining), nextNeighbor) =>
      val (expandedCluster, reducedRemaining) = extractClusterFor(nextNeighbor, remaining, currCluster)
      ((currCluster ++ expandedCluster).distinct, reducedRemaining)
    }
  }
}


/** Contig and strand for the left and right sides of a breakpoint pileup */
case class BreakpointContigOrientation(left_contig: String, left_strand: Char, right_contig: String, right_strand: Char)


object BreakpointContigOrientation {
  def apply(pileup: BreakpointPileup): BreakpointContigOrientation = {
    BreakpointContigOrientation(
      left_contig  = pileup.left_contig,
      left_strand  = pileup.left_strand,
      right_contig = pileup.right_contig,
      right_strand = pileup.right_strand,
    )
  }
}


/** Type of structural variant supported by a pileup */
object BreakpointCategory extends Enumeration {
  type BreakpointCategory = String
  val PossibleDeletion = "Possible deletion"
  val IntraContig = "Intra-contig rearrangement"
  val InterContig = "Inter-contig rearrangement"

  def apply(breakpointPileup: BreakpointPileup): BreakpointCategory = {
    if (breakpointPileup.left_contig != breakpointPileup.right_contig) {
      InterContig
    } else {
      if (breakpointPileup.left_strand != breakpointPileup.right_strand) {
        IntraContig
      } else PossibleDeletion
    }
  }
}


/**
 * Aggregated cluster of breakpoint pileups
 * @param id Combined ID retaining the IDs of all contributing breakpoints
 * @param category Breakpoint category
 * @param left_contig Contig name for left side of breakpoint
 * @param left_min_pos Minimum coordinate of the left sides of all breakpoints
 * @param left_max_pos Maximum coordinate of the left sides of all breakpoints
 * @param left_strand Strand at left side of each breakpoint
 * @param right_contig Contig name for right side of breakpoint
 * @param right_min_pos Minimum coordinate of the right sides of all breakpoints
 * @param right_max_pos Maximum coordinate of the right sides of all breakpoints
 * @param right_strand Strand at right side of each breakpoint
 * @param split_reads Total number of split reads supporting the breakpoints in the cluster
 * @param read_pairs Total number of read pairs supporting the breakpoints in the cluster
 * @param total Total number of templates supporting the breakpoints in the cluster
 */
case class AggregatedBreakpointPileup(id: String,
                                      category: BreakpointCategory,
                                      left_contig: String,
                                      left_min_pos: Int,
                                      left_max_pos: Int,
                                      left_strand: Char,
                                      right_contig: String,
                                      right_min_pos: Int,
                                      right_max_pos: Int,
                                      right_strand: Char,
                                      split_reads: Int,
                                      read_pairs: Int,
                                      total: Int
                                     ) extends Metric {

  /** Returns a new aggregated pileup with the given pileup added */
  def add(pileup: BreakpointPileup): AggregatedBreakpointPileup = {
    assert(pileup.left_contig == left_contig)
    assert(pileup.right_contig == right_contig)
    assert(pileup.left_strand == left_strand)
    assert(pileup.right_strand == right_strand)
    AggregatedBreakpointPileup(
      id              = addId(id, pileup.id),
      category        = category,
      left_contig     = left_contig,
      left_min_pos    = Math.min(left_min_pos, pileup.left_pos),
      left_max_pos    = Math.max(left_max_pos, pileup.left_pos),
      left_strand     = left_strand,
      right_contig    = right_contig,
      right_min_pos   = Math.min(right_min_pos, pileup.right_pos),
      right_max_pos   = Math.max(right_max_pos, pileup.right_pos),
      right_strand    = right_strand,
      split_reads     = split_reads + pileup.split_reads,
      read_pairs      = read_pairs + pileup.read_pairs,
      total           = total + pileup.total,
    )
  }

}


object AggregatedBreakpointPileup {

  def apply(pileups: PileupGroup): AggregatedBreakpointPileup = {
    pileups match {
      case head :: tail =>
        val headAgg = AggregatedBreakpointPileup(
          id            = head.id,
          category      = BreakpointCategory(head),
          left_contig   = head.left_contig,
          left_min_pos  = head.left_pos,
          left_max_pos  = head.left_pos,
          left_strand   = head.left_strand,
          right_contig  = head.right_contig,
          right_min_pos = head.right_pos,
          right_max_pos = head.right_pos,
          right_strand  = head.right_strand,
          split_reads   = head.split_reads,
          read_pairs    = head.read_pairs,
          total         = head.total,
        )
        tail.foldLeft[AggregatedBreakpointPileup](headAgg)((agg, nextPileup) => agg.add(nextPileup))
      case _ => throw new IllegalArgumentException("Pileup group must be non-empty")
    }
  }

  private def addId(existing: String, add: String): String = f"${existing}_$add"

}
